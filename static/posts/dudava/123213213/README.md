# TODO:
- Разобраться с None в json (ЧЕК!)
- Изменить способ именования пакетов (ЧЕК!)
- Изменение уже созданных экземпляров пакетами, пришедшими с хоста (ЧЕК!)
- Создание новых экземпляров из чужих пакетов (ЧЕК!)
- Инициализация объекта данными из пакета при первом получении (ЧЕК!)
- Разбиение объектов по id в client (ЧЕК!)
- При выходе клиента, удалять все созданные им объекты (ЧЕК!)

- Общий объект для всех игроков на сервере (ЧЕК!)
- Синхронизация кирпичиков клиента с состоянием кирпичиков на хосте (ЧЕК!)


## Отложено:
- Сглаживание пинга (Может быть реализовано, исходя из игровых механик. Пока отложено)
- ISynchronizedManager. Синхронизация состояния сервера. (реализовано по-другому)

# Общая концепция

## Присвоение айди

Айди игрока игрока присваивается по правилу первого свободного, начиная с 0.

## Работа с обычными объектами

Экземпляр, обладаюший уникальным именем должен быть добавлен в словарь, создан и синхронизирован. Они распределяются внутри словаря по айди. 

Новый экземпляр добавляется в коде путем использования метода synchronize клиента и название класса. Его имя должно быть получено автоматически исходя из счетчика созданных объектов в классе и айди клиента. Метод должен возвращать экземпляр класса для работы с ним.

Например: "Hero-InId:0-CId:0", Hero - класс, InId - счетчик экземпляров класса, CId - айди игрока.

Если объект уже есть в словаре, его нужно просто обновить.

## Работа с множеством определенных объектов

Если нужно создавать много объектов, нужно использовать класс, наследующий от ISynchronizedManager и передавать данные для него. Он должен хранить информацию о состоянии игрового мира в данный момент и изменяться от запросов игроков. 

Нужна другая концепция: на входе игрок должен получить интересующую его информацию о игровом мире (поле кирпичиков, рекорды игроков и т.д.). Эта информация очевидно хранится на стороне сервера и изменяется тоже на его стороне. То есть помимо определения классов ISynchronizedObject на стороне клиента, нужно еще опеределять классы ISynchronizedManager на стороне сервера.

У класса, наследующего от ISynchronizedManager, может быть только один экземпляр для всех игроков. Методы: получить состояние, изменить. Например: {BrickManager: "required"} - это запрос состояния с хоста, хост отправляет этому клиенту пакет с данными BrickManager. {BrickManager: {"Кирпичек под строкой 1 и столбиком 1": "deleted", ...}} - это запрос на изменение состояния. 
Эти запросы шлются неодновременно:
- Сервер: Начало. -- 100
- Клиент: Заходит в игру отправляет запрос на получение состояния. -- 200
- Сервер: Получает пакет, отправляет состояние. -- 250
- Клиент: Получает состояние, применяет его. 	-- 280
- Клиент: Рендерит сцену, перемещает объекты, отправляет объекты. 	 -- 300
- Сервер: Получает объекты клиента, обновляет информацию на сервере, отправляет клиенту пакет (информация об игроках + состояние сервера). -- 350
- Клиент: Получает объекты, применяет их. -- 380
- Клиент: Изменяет состояние сервера, отправляет в пакете с информацией о себе и изменении состояния. -- 400
- Сервер: Получает пакет, видит в нем имя менеджера состояния, применяет пакет, обновляет данные об игроках, отправляет пакет (информация об игроках + состояние сервера) -- 450

## Отключение игрока

Если клиент отключается, хост присваивает его айди значение "closed", чтоб другие могли его прочитать и удалить из своих словарей его экземляры. 


